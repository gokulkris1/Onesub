
# Firebase Backend Setup for OneSub

This guide walks you through setting up a Firebase project to serve as the backend for the OneSub application. We'll configure Firebase Authentication, Firestore Database, and Firebase Functions.

## 1. Create a Firebase Project

1.  Go to the [Firebase Console](https://console.firebase.google.com/).
2.  Click on "**Add project**".
3.  Enter a name for your project (e.g., "OneSub-App") and follow the on-screen instructions.
4.  It's recommended to enable Google Analytics for this project, but it's optional for basic functionality.
5.  Once your project is created, click "**Continue**". You'll be taken to your project's dashboard.

## 2. Set Up Firebase Authentication

We'll enable Email/Password authentication.

1.  In the Firebase console, navigate to "**Authentication**" (under the "Build" section in the left sidebar).
2.  Click on the "**Get started**" button.
3.  In the "Sign-in method" tab, click on "**Email/Password**" from the list of providers.
4.  Enable the **Email/Password** provider.
5.  Click "**Save**".

## 3. Set Up Firestore Database

Firestore will be our NoSQL database for storing user profiles, subscriptions, bundles, etc.

1.  In the Firebase console, navigate to "**Firestore Database**" (under the "Build" section).
2.  Click on "**Create database**".
3.  Choose to start in **Production mode** (we'll set up security rules later) or **Test mode** if you prefer (be mindful of open access in test mode). For initial development, test mode can be easier, but remember to secure it before going live:
    ```rules
    // Example Test Mode Rules (allows reads/writes for 30 days)
    rules_version = '2';
    service cloud.firestore {
      match /databases/{database}/documents {
        match /{document=**} {
          allow read, write: if request.time < timestamp.date(YYYY, MM, DD + 30); // Replace YYYY, MM, DD
        }
      }
    }
    ```
    A better starting point for **Production mode** that denies all access until you define specific rules:
    ```rules
    rules_version = '2';
    service cloud.firestore {
      match /databases/{database}/documents {
        match /{document=**} {
          allow read, write: if false;
        }
      }
    }
    ```
    You will later update these rules in `firebase-backend/firestore.rules`.
4.  Choose a Firestore location (e.g., a region close to your users). This cannot be changed later.
5.  Click "**Enable**".

## 4. Set Up Firebase CLI and Initialize Firebase Functions

### Install Firebase CLI

If you don't have it already, install the Firebase CLI globally:
```bash
npm install -g firebase-tools
```

### Log In to Firebase
```bash
firebase login
```
This will open a browser window for you to log in with your Google account.

### Initialize Firebase in Your Project

1.  Navigate to the root directory of your OneSub project in your terminal.
2.  Run the following command to initialize Firebase **specifically for Functions and Firestore config (hosting will remain on Vercel for the frontend)**:
    ```bash
    firebase init firestore,functions
    ```
3.  **Project Setup:**
    *   Choose "**Use an existing project**" and select the Firebase project you created earlier.
4.  **Firestore Setup:**
    *   It might ask about Firestore rules file. You can accept the default (`firestore.rules`). We will place this file in `firebase-backend/`.
    *   It might ask about Firestore indexes file. You can accept the default (`firestore.indexes.json`). We will place this file in `firebase-backend/`.
5.  **Functions Setup:**
    *   **Language:** Choose **TypeScript**.
    *   **ESLint:** Choose whether you want to use ESLint (recommended: Yes).
    *   **Install dependencies:** When prompted, choose **Yes** to install dependencies with npm.
    *   This will create a `functions` directory. We will rename and move this to `firebase-backend/functions`.

### Organize Firebase Files

1.  Create a `firebase-backend` directory in your project root if it doesn't exist.
2.  Move the `functions` directory generated by `firebase init` into `firebase-backend/`. So you'll have `firebase-backend/functions/`.
3.  Move `firestore.rules` and `firestore.indexes.json` (if generated) into the `firebase-backend/` directory.

Your `firebase.json` file (in the project root) should look something like this after initialization (we'll refine it):
```json
{
  "firestore": {
    "rules": "firebase-backend/firestore.rules",
    "indexes": "firebase-backend/firestore.indexes.json"
  },
  "functions": [
    {
      "source": "firebase-backend/functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint",
        "npm --prefix \"$RESOURCE_DIR\" run build"
      ]
    }
  ]
}
```
And create a `.firebaserc` file in your project root:
```json
{
  "projects": {
    "default": "YOUR_FIREBASE_PROJECT_ID" // Replace with your actual Firebase Project ID
  }
}
```
You can find your Project ID in the Firebase console -> Project settings.

## 5. Firebase Admin SDK (for Functions)

Firebase Functions that run in the Firebase environment automatically have Admin privileges and can access Firebase services without needing a service account key file explicitly.

If you ever need to run a script *locally* with Admin SDK access (e.g., a data migration script not as a deployed function), you would:
1.  Go to your Firebase project settings in the console.
2.  Navigate to the "Service accounts" tab.
3.  Click on "Generate new private key" and confirm. This will download a JSON file.
    **IMPORTANT: Keep this file secure and do not commit it to your repository.** Add it to your `.gitignore`.
4.  You would then set the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to the path of this JSON file when running your local admin script.
    ```bash
    export GOOGLE_APPLICATION_CREDENTIALS="/path/to/your/serviceAccountKey.json"
    ```
    For deployed Firebase Functions, this step is NOT necessary.

## 6. Environment Configuration for Firebase Functions

If your Firebase Functions need to access external APIs (like the Gemini API if you move the proxy later, or other services), you'll need to set environment variables.

1.  You can set environment variables using the Firebase CLI:
    ```bash
    firebase functions:config:set someservice.key="YOUR_API_KEY" someservice.id="YOUR_ID"
    # Example for Gemini API (if you move the proxy)
    firebase functions:config:set gemini.apikey="YOUR_GEMINI_API_KEY"
    ```
2.  Access these in your functions code:
    ```typescript
    import * as functions from "firebase-functions";
    const apiKey = functions.config().someservice.key;
    const geminiApiKey = functions.config().gemini.apikey;
    ```
3.  To use `functions.config()` locally with the Firebase Emulator Suite:
    ```bash
    firebase functions:config:get > firebase-backend/functions/.runtimeconfig.json
    ```
    (Ensure `.runtimeconfig.json` is in your `firebase-backend/functions/.gitignore`).

## 7. Deploying Firebase Functions

1.  Navigate to your `firebase-backend/functions/` directory.
2.  Write your TypeScript function code in `firebase-backend/functions/src/index.ts` (and other files).
3.  The `package.json` inside `firebase-backend/functions/` will manage dependencies for your functions.
4.  From your project root directory (where `firebase.json` is located):
    ```bash
    firebase deploy --only functions
    ```
    To deploy a specific function:
    ```bash
    firebase deploy --only functions:yourFunctionName
    ```

## 8. Firestore Security Rules (`firebase-backend/firestore.rules`)

It's crucial to define strong security rules for Firestore. Here's a very basic example allowing authenticated users to read/write their own data:

```rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection: allow users to read/write their own document
    match /users/{userId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null; // Allow any authenticated user to create their profile
    }

    // Example: Subscriptions collection (assuming sub-collection under users)
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Bundles: allow any authenticated user to read
    match /bundles/{bundleId} {
      allow read: if request.auth != null;
      // allow write: if false; // Or restrict to admin role via custom claims
    }

    // Add rules for other collections (admin data, provider data, etc.)
    // Example for admin-only write access to a collection
    // match /adminOnlyData/{docId} {
    //   allow read, write: if request.auth != null && request.auth.token.admin == true;
    // }
    // To use request.auth.token.admin, you need to set custom claims for admin users.

    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
```
**You will need to expand these rules based on your application's specific data structure and access requirements.** Learn more about [Firebase Security Rules](https://firebase.google.com/docs/rules).

This setup provides a solid foundation for your OneSub backend using Firebase. Remember to iterate on your Firestore data model and security rules as you develop features.
